// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Assignment1PAPYRUS;

/************************************************************/
/**
 * 
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Board {
	private Tile[] tiles = new Tile[19];
	private Node[] nodes = new Node[54];
	private List<Edge> edges = new ArrayList<>();

	public int[][] tileNodes = {

			//hard wire tileNodes, for each tile, we have their corresponding node identification number
			//the midde
			{0,1,2,3,4,5}, //tile 0

			//inner ring
			{6,7,8,9,2,1}, //tile 1
			{2,9,10,11,12,3}, //tile 2
			{4,3,12,13,14,15}, //tile 3
			{16,5,4,15,17,18}, //tile 4
			{19,20,0,5,16,21}, //tile 5
			{22,23,6,1,0,20},  //tile 6
			//outer ring
			{24,25,26,27,8,7}, //tile 7
			{8,27,28,29,10,9}, //tile 8
			{10,29,30,31,32,11}, //tile 9
			{12,11,32,33,34,13}, //tile 10
			{14,13,34,35,36,37}, //tile 11
			{17,15,14,37,38,39}, //tile 12
			{40,18,17,39,41,42}, //tile 13
			{43,21,16,18,40,44}, //tile 14
			{47,46,19,21,43,45}, //tile 15
			{48,49,22,20,19,46}, //tile 16
			{50,51,52,23,22,49}, //tile 17
			{52,53,24,7,6,23} //tile 18
	};

	public Board() {
		//creating the nodes
		for (int i = 0; i < 54; i++) nodes[i] = new Node(i);

		//hard wiring the terrain tiles (numbers is the dice probabilities for tiles 0 to 18) then the corresponding fields
		int[] numbers = {10,11,8,3,11,5,12,3,6,4,6,9,5,9,8,4,7,2,10};
		Terrain[] terrains = {
				Terrain.FOREST, Terrain.FIELDS, Terrain.HILLS, Terrain.MOUNTAINS, Terrain.PASTURE, Terrain.PASTURE,
				Terrain.PASTURE, Terrain.FIELDS, Terrain.MOUNTAINS, Terrain.FOREST, Terrain.MOUNTAINS, Terrain.FIELDS,
				Terrain.FOREST, Terrain.HILLS, Terrain.HILLS, Terrain.FIELDS, Terrain.DESERT, Terrain.FOREST, Terrain.PASTURE
		};


		for (int i = 0; i < 19; i++) {
			tiles[i] = new Tile(i, terrains[i], numbers[i]);
		}

		//if 2 nodes appear sequentially in a tile then they share an edge
		int edgeIdCounter = 0;
		for (int[] tNodes : tileNodes) {
			for (int i = 0; i < 6; i++) {
				int u = tNodes[i];
				int v = tNodes[(i + 1) % 6];
				if (getEdgeBetween(u, v) == null) {
					edges.add(new Edge(edgeIdCounter++, u, v));
				}
			}
		}
	}


	public int firstEmptyEdgeTouchingNode(int nodeId) {
		for (Edge e : edges) {
			if (e.empty() && (e.getEndpoint1() == nodeId || e.getEndpoint2() == nodeId)) return e.getId();
		}
		return -1;
	}

	//this one can find the edge between 2 nodes
	public Edge getEdgeBetween(int u, int v) {
		for (Edge e : edges) {
			if ((e.getEndpoint1() == u && e.getEndpoint2() == v) || (e.getEndpoint1() == v && e.getEndpoint2() == u)) {
				return e;
			}
		}
		return null;
	}


	public Tile tile(int tileId) { return tiles[tileId]; }
	public Node node(int nodeId) { return nodes[nodeId]; }
	public Edge edge(int edgeId) { return edges.get(edgeId); }
	public int[] nodesAroundTile(int tileId) { return tileNodes[tileId]; }

	//legality logic, can they place a road?
	public boolean canPlaceRoad(int playerId, int edgeId) {
		Edge e = edge(edgeId);
		if (!e.empty()) return false;

		//you have to connect to existing road of the same player
		boolean connectsToBuilding = (node(e.getEndpoint1()).getOwner() == playerId) || (node(e.getEndpoint2()).getOwner() == playerId);

		//check connecting raods
		boolean connectsToRoad = false;
		for (Edge neighbor : edges) {
			if (neighbor.getRoadOwner() == playerId && (neighbor.getEndpoint1() == e.getEndpoint1() || neighbor.getEndpoint1() == e.getEndpoint2() || neighbor.getEndpoint2() == e.getEndpoint1() || neighbor.getEndpoint2() == e.getEndpoint1())) {
				connectsToRoad = true;
			}
		}
		return connectsToBuilding || connectsToRoad;
	}

	public boolean canPlaceSettlement(int playerId, int nodeId, Phase phase) {
		Node n = node(nodeId);
		if (!n.empty()) return false;

		//rule: no neighbor node can have a building
		for (Edge e : edges) {
			if (e.getEndpoint1() == nodeId || e.getEndpoint2() == nodeId) {
				int neighborId = (e.getEndpoint1() == nodeId) ? e.getEndpoint2() : e.getEndpoint1();
				if (!node(neighborId).empty()) return false;
			}
		}

		if (phase == Phase.SETUP) return true;

		//this is the main phase, must connect to road
		for (Edge e : edges) {
			if ((e.getEndpoint1() == nodeId || e.getEndpoint2() == nodeId) && e.getRoadOwner() == playerId) {
				return true;
			}
		}
		return false;
	}

	//check legality for upgrading to city
	public boolean canUpgradeToCity(int playerId, int nodeId) {
		Node n = node(nodeId);
		return n.getOwner() == playerId && n.getBuilding() == BuildingType.SETTLEMENT;
	}

	//mutators
	public void placeRoad(int playerId, int edgeId) {
		edge(edgeId).setRoadOwner(playerId);
	}

	public void placeSettlement(int playerId, int nodeId) {
		node(nodeId).setBuilding(playerId, BuildingType.SETTLEMENT);
	}

	public void upgradeToCity(int playerId, int nodeId) {
		node(nodeId).setBuilding(playerId, BuildingType.CITY);
	}

	public Node[] getNodes() {
		return nodes.clone();
	}

	//using shallow copy to get the tiles edges etc
	public List<Edge> getEdges() {
		return Collections.unmodifiableList(edges);
	}

	public Tile[] getTiles() {
		return tiles.clone();
	}

	//optional getter (might not need this )
	public int[] nodesAroundTileCopy(int tileId) {
		return tileNodes[tileId].clone();
	}

}
