// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Assignment1PAPYRUS;

/************************************************************/
/**
 * 
 */
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class Game {
	private Board board;
	private Bank bank;
	private TurnManager turns;
	private Dice dice;
	private Player[] players;

	public Game(Board board, Bank bank, TurnManager turns, Dice dice, Player[] players) {
		this.board = board;
		this.bank = bank;
		this.turns = turns;
		this.dice = dice;
		this.players = players;
	}

	public Board board() { return board; }
	public Phase phase() { return turns.phase(); }

	public void run(int maxTurns) {
		//initial setup, give everyone 2 settlemenets
		setupPhase();
		turns.setPhase(Phase.MAIN);

		int round = 1;
		while (round <= maxTurns) {
			Player p = players[turns.currentPlayerIndex()];

			//roll dice
			int roll = dice.roll();
			int roundNumber = (round - 1) / 4 + 1;
			System.out.println("[Round " + roundNumber + " / P" + p.id() + "]: Rolled " + roll);

			//then dist resources
			if (roll != 7) distributeResources(roll);

			//then player action
			p.takeTurn(this);

			//then check win
			//termination logic
			if (p.vp() >= 10) {
				System.out.println("Player " + p.id() + " WINS with " + p.vp() + " VP!");
				return;
			}

			//print the end of the round
			if (turns.currentPlayerIndex() == 3) {
				System.out.print("End of Round " + roundNumber + " VPs: ");
				for(Player pl : players) System.out.print("P" + pl.id() + ":" + pl.vp() + " ");
				System.out.println();
			}

			turns.nextTurn(4);
			round++;
		}
	}

	private void setupPhase() {
		System.out.println("SETUP PHASE");

		int[] order = {0,1,2,3,3,2,1,0};

		for (int i = 0; i < order.length; i++) {
			int pid = order[i]; //get player id

			int nodeId = pickSetupSettlement(pid); //find a legal empty node
			board.placeSettlement(pid, nodeId);
			players[pid].setSettlementsLeft(players[pid].getSettlementsLeft()-1);
			players[pid].addVictoryPoints(1);

			int edgeId = board.firstEmptyEdgeTouchingNode(nodeId);
			if (edgeId != -1) {
				board.placeRoad(pid, edgeId);
				players[pid].setRoadsLeft(players[pid].getRoadsLeft()-1);
			}

			System.out.println("[Setup / P" + pid + "]: Placed Settlement at " + nodeId
					+ " and Road at " + edgeId);

			//grant the initial resources (second settlement)
			if (i >= 4) grantInitialResourcesFromNode(pid, nodeId);
		}
	}
	//resource production method
	//distribute resources to players for a given dice roll depending on the players current settlement/city positions
	private void distributeResources(int roll) {
		for (Tile t : board.getTiles()) {
			if (t.getNumber() == roll && t.getTerrain() != Terrain.DESERT) {
				int[] nodes = board.nodesAroundTile(t.getId());
				for (int nodeId : nodes) {
					Node n = board.node(nodeId);
					if (!n.empty()) {
						int amount = (n.getBuilding() == BuildingType.CITY) ? 2 : 1;
						Player receiver = players[n.getOwner()];
						Resource r = t.getResource();
						if (bank.canGive(r, amount)) {
							bank.give(receiver, r, amount);
							System.out.println("   -> P" + receiver.id() + " got " + amount + " " + r);
						}
					}
				}
			}
		}
	}

	//the build methods (building roads settlement, and upgrading to city)
	public boolean buildRoad(Player p, int edgeID) {
		Map<Resource, Integer> cost = Map.of(Resource.BRICK, 1, Resource.WOOD, 1);
		if (p.hasResources(cost) && board.canPlaceRoad(p.id(), edgeID)) {
			p.pay(cost);
			board.placeRoad(p.id(), edgeID);
			p.setRoadsLeft(p.getRoadsLeft()-1);
			System.out.println("[Main / P" + p.id() + "]: Built Road at Edge " + edgeID);
			return true;
		}
		return false;
	}

	public boolean buildSettlement(Player p, int nodeID) {
		Map<Resource, Integer> cost = Map.of(Resource.BRICK, 1, Resource.WOOD, 1, Resource.WHEAT, 1, Resource.SHEEP, 1);
		if (p.hasResources(cost) && board.canPlaceSettlement(p.id(), nodeID, turns.phase())) {
			p.pay(cost);
			board.placeSettlement(p.id(), nodeID);
			p.setSettlementsLeft(p.getSettlementsLeft()-1);
			p.addVictoryPoints(1);
			System.out.println("[Main / P" + p.id() + "]: Built Settlement at Node " + nodeID);
			return true;
		}
		return false;
	}

	public boolean upgradeToCity(Player p, int nodeID) {
		Map<Resource, Integer> cost = Map.of(Resource.ORE, 3, Resource.WHEAT, 2);
		if (p.hasResources(cost) && board.canUpgradeToCity(p.id(), nodeID)) {
			p.pay(cost);
			board.upgradeToCity(p.id(), nodeID);
			p.setSettlementsLeft(p.getSettlementsLeft()+1); //give the settlement back
			p.setCitiesLeft(p.getCitiesLeft()-1);
			p.addVictoryPoints(1); //+1 net vp from city
			System.out.println("[Main / P" + p.id() + "]: Upgraded to City at Node " + nodeID);
			return true;
		}
		return false;
	}

	private Random setupRand = new Random();

	//method for randomizng the initial settelement placement to randomize the simulations
	private int pickSetupSettlement(int playerId) {
		List<Integer> choices = new ArrayList<>();
		for (int nodeId = 0; nodeId < board.getNodes().length; nodeId++) {
			if (board.canPlaceSettlement(playerId, nodeId, Phase.SETUP)) choices.add(nodeId);
		}
		if (choices.isEmpty()) throw new IllegalStateException("No legal setup settlement found.");
		return choices.get(setupRand.nextInt(choices.size()));
	}

	private void grantInitialResourcesFromNode(int playerId, int nodeId) {
		//give 1 resource from one adjacent tile
		for (Tile t : board.getTiles()) {
			if (t.getTerrain() == Terrain.DESERT) continue;
			for (int n : board.nodesAroundTile(t.getId())) {
				if (n == nodeId) {
					Resource r = t.getResource();
					bank.give(players[playerId], r, 1);
					System.out.println("   -> [Setup / P" + playerId + "]: Gained 1 " + r + " (tile " + t.getId() + ")");
					break;
				}
			}
		}
	}

}
